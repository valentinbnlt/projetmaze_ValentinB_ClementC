"""
title: Generate Mazes with Kruksal algorithm and solve it with dfs
author: qkzk
date: 2021/05/09
"""

from random import choice
from typing import Union
from union_find_forest import UnionFind


class Cell:
    """
    Holds a Cell of the Maze
    """

    def __init__(self, i: int, j: int, width: int, height: int):
        self.i = i
        self.j = j
        self.width = width
        self.height = height
        self._neighbors = self._create_neighbors()

    def _create_neighbors(self) -> list:
        """Initiate the list of neighbors"""
        return [
            (self.i + i, self.j + j)
            for i in range(-1, 2)
            for j in range(-1, 2)
            if self._is_wall_valid(i, j)
        ]

    @property
    def neighbors(self) -> list:
        """Getter for the neighbors"""
        return self._neighbors

    def is_neighbor(self, other: "Cell") -> bool:
        """True iff the `other` `Cell` is a neighbor of `self`"""
        return (other.i, other.j) in self.neighbors

    def _is_wall_valid(self, i: int, j: int) -> bool:
        """True iff there's may be a wall between us and `Cell(self.i+i, self.j+j)`"""
        return (
            (i != 0 or j != 0)
            and (i == 0 or j == 0)
            and (self.i + i >= 0)
            and (self.j + j >= 0)
            and (self.i + i < self.width)
            and (self.j + j < self.height)
        )

    def __eq__(self, other):
        return self.i == other.i and self.j == other.j

    def __lt__(self, other):
        if self.j < other.j:
            return True
        if self.j == other.j and self.i < other.i:
            return True
        return False

    def __hash__(self):
        return hash((self.i, self.j))

    def __repr__(self):
        return f"Cell({self.i}, {self.j}, {self.width}, {self.height})"


class Maze:
    """Holds a perfect random Maze generated by the Kruksal's algorithm"""

    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.cells = sorted(self._init_cells())
        self.walls = self._init_walls()
        self.unionfind=UnionFind(self.cells)
        self.graphe = Graphes(self.cells)
        self.generation()
        self.chemin = []
        print(self.__repr__())
        self.chemin = self.graphe.construire_chemin(Cell(0,0,self.width,self.height),Cell(self.width-1, self.height-1, self.width, self.height))       
        print(self.__repr__())


    def _init_cells(self) -> list:
        """initiate the cells"""
        return [
            Cell(i, j, self.width, self.height)
            for i in range(self.width)
            for j in range(self.height)
        ]

    def generation(self):
        while self.unionfind.number_of_classes() > 1:
            mur_actuel = choice(self.walls)
            if self.unionfind.find(mur_actuel[0]) != self.unionfind.find(mur_actuel[1]):
                self.walls.remove(mur_actuel)
                self.unionfind.union(mur_actuel[0], mur_actuel[1])
                self.graphe.ajouter_arrete(mur_actuel[0], mur_actuel[1])
            

    def _init_walls(self) -> list:
        """initiate the walls: every pair of neighboring cells have a wall between them"""
        return [
            (cell_a, cell_b)
            for cell_a in self.cells
            for cell_b in self.cells
            if cell_a < cell_b and cell_a.is_neighbor(cell_b)
        ]

    def have_wall(self, i: int, j: int, x: int, y: int) -> bool:
        """True iff there's a wall between Cell(i, j) and Cell(x, y)"""
        return (
            Cell(i, j, self.width, self.height),
            Cell(x, y, self.width, self.height),
        ) in self.walls or (
            Cell(x, y, self.width, self.height),
            Cell(i, j, self.width, self.height),
        ) in self.walls

    def _formatted_string(self) -> str:
        string = "+-" * self.width + "+\n"
        for j in range(self.height):
            string += "│{}"
            for i in range(self.width - 1):
                if self.have_wall(i, j, i + 1, j):
                    string += "│{}"
                else:
                    string += " {}"
            string += "|\n"
            if j < self.height - 1:
                for i in range(self.width):
                    if self.have_wall(i, j, i, j + 1):
                        string += "+-"
                    else:
                        string += "+ "
                string += "+\n"
        string += "+-" * self.width + "+\n"
        return string

    def __repr__(self):
        return self._formatted_string().format(*self.liste_solution())
    
    def liste_solution(self):
        solution = []
        for cell in self.cells:
            if cell in self.chemin:
                solution.append("#")
            else:
                solution.append(" ")
        return solution    


class Graphes:
    def __init__(self, sommets):
        self.liste_des_sommets = []
        self.liste_des_arretes = {}
        for sommet in sommets:
            self.ajouter_sommet(sommet)


    def ajouter_sommet(self, sommet):
        self.liste_des_sommets.append(sommet)
        self.liste_des_arretes[sommet] = []


    def ajouter_arrete(self,sommet1,sommet2):
        self.liste_des_arretes[sommet1].append(sommet2)
        self.liste_des_arretes[sommet2].append(sommet1)

    def voisins(self,sommet):

        return self.liste_des_arretes[sommet]


    def parcourir_predecesseurs(self, source):
        '''
        Retourne la liste predecesseurs visités dans l'ordre d'un parcours en profondeur
        '''
        pile = []
        predecesseurs = {source: None}

        pile.append(source) # empiler

        while pile:
            courant = pile.pop() # dépiler
            for voisin in self.voisins(courant):
                if not voisin in predecesseurs:
                    pile.append(voisin)
                    predecesseurs[voisin] = courant 

        return predecesseurs


    def construire_chemin(self, source, destination):
        """doc"""
        predecesseurs = self.parcourir_predecesseurs(source)
  
        if not destination in predecesseurs:
            return None

        chemin = [destination]
        courant = destination 
        while courant != source:
            courant = predecesseurs[courant]
            chemin.append(courant) 
        chemin = chemin[::-1]
        return chemin


def tests():
    """tests the methods"""
    maze = Maze(10, 10)


if __name__ == "__main__":
    tests()

